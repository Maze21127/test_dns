Тестовое задание на позицию Junior Fullstack Python разработчик.  

**ВАЖНО**: Обратите внимание на вторую ветку.  
В ней работа с БД реализована другим способом, что позволило более декомпозировать мой код.

- [Описание задачи](#описание-задачи)
- [Описание эксплуатации сервиса](#Описание-эксплуатации-сервиса)
  - [Установка и запуск](#установка-и-запуск)
    - [Production](#production)
    - [Dev](#dev)
  - [Работа с сервисом](#работа-с-сервисом)
    - [Документация](#документация)
      - [Города](#cities)
        - [Создать город](#создать-новый-город)
        - [Удалить все города](#удалить-все-города)
        - [Найти кратчайшее расстояние между двумя городами](#найти-кратчайшее-расстояние-между-двумя-городами-)
      - [Связи](#edges)
        - [Создать связь](#создать-новую-связь)
        - [Удалить все связи](#удалить-все-связи)
  - [Запуск тестов](#запуск-тестов)
- [Описание решения задачи](#описание-решения-задачи)

# Описание задачи
## FSP Service

FSP Service — это FastAPI приложение, которое помогает пользователю находить кратчайшее расстояние между городами.

Структура API может выглядеть так:

```
/cities/{city}/findShortestPath?to={targetCity}
```

Структура ответа:

```json
{
    
    "city": "City Name",
    "result":
        {
            "distance": 100,
            "targetCity": "Target City Name"
        }  
}
```


### Задача

* Обдумать способ хранения графа городов из `sample.txt` в Postgres;
* Реализовать выбранный подход и заполнить таблицы;
* Реализовать алгоритм поиска кратчайшего пути;
* Реализовать сервис с использованием FastAPI и SQLAlchemy.

### Требования

* Таблицы должны соответствовать DKNF;
* Сервис должен иметь несколько слабосвязных слоёв логики;
* Необходимо использовать Pydantic для формирования DTO и конфигурации приложения;
* Работу с БД организовать с использованием `starlette app.state`


### Ожидаемый результат

Репозиторий должен содержать:

* Исходный код;
* Dockerfile для сервиса;
* Docker-compose для работы сервиса и PostgreSQL;
* TestClient для проверки результатов работы алгоритма;
* README.md с описанием эксплуатации сервиса;
* README.md с описанием решения задачи и указанием причин выбора реализованного подхода.

# Описание эксплуатации сервиса
### Установка и запуск
- Клонирование репозитория
```bash
git clone ...
```
#### Production
- Установить переменную окружения DEV
```bash
export DEV=False
```
- Создание файла .env
```bash
mv .env.dist .env 
```
- Подготовка
  - Заполнить файл .env
  - Запустить команды
```bash
docker-compose build
docker-compose up
```
- Перейти по адресу http://127.0.0.1:8000/docs (порт из .env)

#### Dev
- Установить переменную окружения DEV
```bash
export DEV=True
```

- Подготовка
  - При необходимости изменить файл .env.dev
  - Запустить команды
```bash
docker-compose -f docker-compose-dev.yml build
docker-compose -f docker-compose-dev.yml up
```
Данные команды поднимут тестовую базу данных

- Запустить миграции
```bash
alembic upgrade heads
```

- Запуск локального сервера
```bash
uvicorn app.main:app --reload 
```
- Перейти по адресу http://127.0.0.1:8000/docs

### Работа с сервисом
1. Сделать запрос на следующий адрес и добавить файл sample.txt
```bash
/api/cities/fromFile
```
Это загрузит в базу города и связи между ними.

### Документация
#### Cities
#### Получить список городов из базы данных.
```bash
GET /api/cities
```

#### Создать новый город
```bash
POST /api/cities
```
Тело запроса: 
```json
{
  "name": "Renton"
}
```
Возвращаемый тип:
```json
{
  "id": 0,
  "name": "Renton"
}
```

#### Удалить все города
Перед удалением может потребоваться удалить все связи.
```bash
DELETE /api/cities
```

#### Найти кратчайшее расстояние между двумя городами 
```bash
GET /api/cities/{cityFrom}/findShortestPath?to={cityTo}
```
Возвращаемый тип:
```json
{
  "city": "cityFrom",
  "result": {
    "distance": 0,
    "targetCity": "cityTo"
  }
}
```

#### Edges
#### Создать новую связь
```bash
POST /api/edges
```
Тело запроса: 
```json
{
  "from_city_id": 0,
  "to_city_id": 0,
  "distance": 0
}
```
В случае успеха возвращается добавленная связь   
Возвращаемый тип:
```json
{
  "from_city_id": 0,
  "to_city_id": 0,
  "distance": 0
}
```

#### Удалить все связи
```bash
DELETE /api/edges
```

### Запуск тестов
Для запуска тестов переменная окружения DEV должна быть True
```bash
export DEV=True
```
Запуск
```bash
pytest
```
Будет создана тестовая база, загружены города из файла и проверен целевой маршрут.
Тесты:
- Расстояния от города А до города А должно равняться 0
- Расстояние от города А до города Б возвращает верный формат
- Статус-код ответа при несуществующих городах - 404
- 8 тестов на проверку кратчайшего пути между различными городами. Для проверки использовался Алгоритм Дейкстры.

# Описание решения задачи
#### Alembic / миграции
Для более удобной работы с созданием и обновлением таблиц используются миграции с применением инструмента Alembic.  

Возможно, для данного кейса это избыточно, я хотел показать, что знаком с данной технологией.  
На проектах масштабнее он мне сильно помогал.
#### .env / переменные окружения
Все чувствительные данные должны храниться только локально и не должны быть выгружены даже в приватный репозиторий.
#### Работа с БД
В данном решении SQLAlchemy используется только для описания таблиц, так как, одним из требований было использование starlette app.state для работы с БД.

В другой ветке реализовано решение без использования starlette app.state, с полноценным использованием SQLAlchemy и инъекцией зависимости сессии.
#### FastAPI Router
Используется для разделения приложения на разные"блоки".  

В обработчиках происходит извлечение соединения с БД из app.state и передача его как аргумент в функции бизнес-логики (app.service)

#### Pydantic
Используется для более удобной работы с разными объектами.  
Гораздо удобнее работать с типизированными объектами, чем с "сырыми" словарями/кортежами.